var j=Object.defineProperty;var I=(e,n,t)=>n in e?j(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t;var _=(e,n,t)=>I(e,typeof n!="symbol"?n+"":n,t);var $=Object.defineProperty,U=(e,n)=>{for(var t in n)$(e,t,{get:n[t],enumerable:!0})},x={};U(x,{audioClassification:()=>F,audioToAudio:()=>J,automaticSpeechRecognition:()=>Q,chatCompletion:()=>pt,chatCompletionStream:()=>wt,documentQuestionAnswering:()=>gt,featureExtraction:()=>rt,fillMask:()=>it,imageClassification:()=>X,imageSegmentation:()=>K,imageToImage:()=>et,imageToText:()=>Z,objectDetection:()=>Y,questionAnswering:()=>at,request:()=>o,sentenceSimilarity:()=>st,streamingRequest:()=>k,summarization:()=>ot,tableQuestionAnswering:()=>ut,tabularClassification:()=>At,tabularRegression:()=>ht,textClassification:()=>ct,textGeneration:()=>ft,textGenerationStream:()=>lt,textToImage:()=>tt,textToSpeech:()=>G,tokenClassification:()=>yt,translation:()=>dt,visualQuestionAnswering:()=>bt,zeroShotClassification:()=>mt,zeroShotImageClassification:()=>nt});function R(e,n){return Object.assign({},...n.map(t=>{if(e[t]!==void 0)return{[t]:e[t]}}))}function z(e,n){return e.includes(n)}function N(e,n){const t=Array.isArray(n)?n:[n],i=Object.keys(e).filter(r=>!z(t,r));return R(e,i)}function A(e){return/^http(s?):/.test(e)||e.startsWith("/")}var w=new Map,L=10*60*1e3,D=1e3,H="https://huggingface.co";async function S(e,n,t){if(A(e))return null;const i=`${e}:${n}`;let r=w.get(i);if(r&&r.date<new Date(Date.now()-L)&&(w.delete(i),r=void 0),r===void 0){const a=await((t==null?void 0:t.fetch)??fetch)(`${H}/api/models/${e}?expand[]=pipeline_tag`,{headers:n?{Authorization:`Bearer ${n}`}:{}}).then(s=>s.json()).then(s=>s.pipeline_tag).catch(()=>null);if(!a)return null;r={task:a,date:new Date},w.set(i,{task:a,date:new Date}),w.size>D&&w.delete(w.keys().next().value)}return r.task}var C="https://api-inference.huggingface.co",h=null;async function q(e,n){const{accessToken:t,endpointUrl:i,...r}=e;let{model:a}=e;const{forceTask:s,includeCredentials:c,taskHint:f,wait_for_model:l,use_cache:d,dont_load_model:y,chatCompletion:E}=n??{},m={};if(t&&(m.Authorization=`Bearer ${t}`),!a&&!h&&f){const g=await fetch(`${H}/api/tasks`);g.ok&&(h=await g.json())}if(!a&&h&&f){const g=h[f];g&&(a=g.models[0].id)}if(!a)throw new Error("No model provided, and no default model found for this task");const p="data"in e&&!!e.data;p||(m["Content-Type"]="application/json"),l&&(m["X-Wait-For-Model"]="true"),d===!1&&(m["X-Use-Cache"]="false"),y&&(m["X-Load-Model"]="0");let V=(()=>{if(i&&A(a))throw new TypeError("Both model and endpointUrl cannot be URLs");return A(a)?(console.warn("Using a model URL is deprecated, please use the `endpointUrl` parameter instead"),a):i||(s?`${C}/pipeline/${s}/${a}`:`${C}/models/${a}`)})();E&&!V.endsWith("/chat/completions")&&(V+="/v1/chat/completions");let b;typeof c=="string"?b=c:c===!0&&(b="include");const B={headers:m,method:"POST",body:p?e.data:JSON.stringify({...r.model&&A(r.model)?N(r,"model"):r}),...b&&{credentials:b},signal:n==null?void 0:n.signal};return{url:V,info:B}}async function o(e,n){var a,s;const{url:t,info:i}=await q(e,n),r=await((n==null?void 0:n.fetch)??fetch)(t,i);if((n==null?void 0:n.retry_on_error)!==!1&&r.status===503&&!(n!=null&&n.wait_for_model))return o(e,{...n,wait_for_model:!0});if(!r.ok){if((a=r.headers.get("Content-Type"))!=null&&a.startsWith("application/json")){const c=await r.json();if([400,422,404,500].includes(r.status)&&(n!=null&&n.chatCompletion))throw new Error(`Server ${e.model} does not seem to support chat completion. Error: ${c.error}`);if(c.error)throw new Error(JSON.stringify(c.error))}throw new Error("An error occurred while fetching the blob")}return(s=r.headers.get("Content-Type"))!=null&&s.startsWith("application/json")?await r.json():await r.blob()}function P(e){let n,t,i,r=!1;return function(s){n===void 0?(n=s,t=0,i=-1):n=W(n,s);const c=n.length;let f=0;for(;t<c;){r&&(n[t]===10&&(f=++t),r=!1);let l=-1;for(;t<c&&l===-1;++t)switch(n[t]){case 58:i===-1&&(i=t-f);break;case 13:r=!0;case 10:l=t;break}if(l===-1)break;e(n.subarray(f,l),i),f=t,i=-1}f===c?n=void 0:f!==0&&(n=n.subarray(f),t-=f)}}function M(e,n,t){let i=T();const r=new TextDecoder;return function(s,c){if(s.length===0)t==null||t(i),i=T();else if(c>0){const f=r.decode(s.subarray(0,c)),l=c+(s[c+1]===32?2:1),d=r.decode(s.subarray(l));switch(f){case"data":i.data=i.data?i.data+`
`+d:d;break;case"event":i.event=d;break;case"id":e(i.id=d);break;case"retry":const y=parseInt(d,10);isNaN(y)||n(i.retry=y);break}}}}function W(e,n){const t=new Uint8Array(e.length+n.length);return t.set(e),t.set(n,e.length),t}function T(){return{data:"",event:"",id:"",retry:void 0}}async function*k(e,n){var l,d;const{url:t,info:i}=await q({...e,stream:!0},n),r=await((n==null?void 0:n.fetch)??fetch)(t,i);if((n==null?void 0:n.retry_on_error)!==!1&&r.status===503&&!(n!=null&&n.wait_for_model))return yield*k(e,{...n,wait_for_model:!0});if(!r.ok){if((l=r.headers.get("Content-Type"))!=null&&l.startsWith("application/json")){const y=await r.json();if([400,422,404,500].includes(r.status)&&(n!=null&&n.chatCompletion))throw new Error(`Server ${e.model} does not seem to support chat completion. Error: ${y.error}`);if(y.error)throw new Error(y.error)}throw new Error(`Server response contains error: ${r.status}`)}if(!((d=r.headers.get("content-type"))!=null&&d.startsWith("text/event-stream")))throw new Error("Server does not support event stream content type, it returned "+r.headers.get("content-type"));if(!r.body)return;const a=r.body.getReader();let s=[];const f=P(M(()=>{},()=>{},y=>{s.push(y)}));try{for(;;){const{done:y,value:E}=await a.read();if(y)return;f(E);for(const m of s)if(m.data.length>0){if(m.data==="[DONE]")return;const p=JSON.parse(m.data);if(typeof p=="object"&&p!==null&&"error"in p)throw new Error(p.error);yield p}s=[]}}finally{a.releaseLock()}}var u=class extends TypeError{constructor(e){super(`Invalid inference output: ${e}. Use the 'request' method with the same parameters to do a custom call with no type checking.`),this.name="InferenceOutputError"}};async function F(e,n){const t=await o(e,{...n,taskHint:"audio-classification"});if(!(Array.isArray(t)&&t.every(r=>typeof r.label=="string"&&typeof r.score=="number")))throw new u("Expected Array<{label: string, score: number}>");return t}async function Q(e,n){const t=await o(e,{...n,taskHint:"automatic-speech-recognition"});if(!(typeof(t==null?void 0:t.text)=="string"))throw new u("Expected {text: string}");return t}async function G(e,n){const t=await o(e,{...n,taskHint:"text-to-speech"});if(!(t&&t instanceof Blob))throw new u("Expected Blob");return t}async function J(e,n){const t=await o(e,{...n,taskHint:"audio-to-audio"});if(!(Array.isArray(t)&&t.every(r=>typeof r.label=="string"&&typeof r.blob=="string"&&typeof r["content-type"]=="string")))throw new u("Expected Array<{label: string, blob: string, content-type: string}>");return t}async function X(e,n){const t=await o(e,{...n,taskHint:"image-classification"});if(!(Array.isArray(t)&&t.every(r=>typeof r.label=="string"&&typeof r.score=="number")))throw new u("Expected Array<{label: string, score: number}>");return t}async function K(e,n){const t=await o(e,{...n,taskHint:"image-segmentation"});if(!(Array.isArray(t)&&t.every(r=>typeof r.label=="string"&&typeof r.mask=="string"&&typeof r.score=="number")))throw new u("Expected Array<{label: string, mask: string, score: number}>");return t}async function Z(e,n){var i;const t=(i=await o(e,{...n,taskHint:"image-to-text"}))==null?void 0:i[0];if(typeof(t==null?void 0:t.generated_text)!="string")throw new u("Expected {generated_text: string}");return t}async function Y(e,n){const t=await o(e,{...n,taskHint:"object-detection"});if(!(Array.isArray(t)&&t.every(r=>typeof r.label=="string"&&typeof r.score=="number"&&typeof r.box.xmin=="number"&&typeof r.box.ymin=="number"&&typeof r.box.xmax=="number"&&typeof r.box.ymax=="number")))throw new u("Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>");return t}async function tt(e,n){const t=await o(e,{...n,taskHint:"text-to-image"});if(!(t&&t instanceof Blob))throw new u("Expected Blob");return t}function v(e){if(globalThis.Buffer)return globalThis.Buffer.from(e).toString("base64");{const n=[];return e.forEach(t=>{n.push(String.fromCharCode(t))}),globalThis.btoa(n.join(""))}}async function et(e,n){let t;e.parameters?t={...e,inputs:v(new Uint8Array(e.inputs instanceof ArrayBuffer?e.inputs:await e.inputs.arrayBuffer()))}:t={accessToken:e.accessToken,model:e.model,data:e.inputs};const i=await o(t,{...n,taskHint:"image-to-image"});if(!(i&&i instanceof Blob))throw new u("Expected Blob");return i}async function nt(e,n){const t={...e,inputs:{image:v(new Uint8Array(e.inputs.image instanceof ArrayBuffer?e.inputs.image:await e.inputs.image.arrayBuffer()))}},i=await o(t,{...n,taskHint:"zero-shot-image-classification"});if(!(Array.isArray(i)&&i.every(a=>typeof a.label=="string"&&typeof a.score=="number")))throw new u("Expected Array<{label: string, score: number}>");return i}async function rt(e,n){const t=e.model?await S(e.model,e.accessToken,n):void 0,i=await o(e,{...n,taskHint:"feature-extraction",...t==="sentence-similarity"&&{forceTask:"feature-extraction"}});let r=!0;const a=(s,c,f=0)=>f>c?!1:s.every(l=>Array.isArray(l))?s.every(l=>a(l,c,f+1)):s.every(l=>typeof l=="number");if(r=Array.isArray(i)&&a(i,3,0),!r)throw new u("Expected Array<number[][][] | number[][] | number[] | number>");return i}async function it(e,n){const t=await o(e,{...n,taskHint:"fill-mask"});if(!(Array.isArray(t)&&t.every(r=>typeof r.score=="number"&&typeof r.sequence=="string"&&typeof r.token=="number"&&typeof r.token_str=="string")))throw new u("Expected Array<{score: number, sequence: string, token: number, token_str: string}>");return t}async function at(e,n){const t=await o(e,{...n,taskHint:"question-answering"});if(!(typeof t=="object"&&!!t&&typeof t.answer=="string"&&typeof t.end=="number"&&typeof t.score=="number"&&typeof t.start=="number"))throw new u("Expected {answer: string, end: number, score: number, start: number}");return t}async function st(e,n){const t=e.model?await S(e.model,e.accessToken,n):void 0,i=await o(e,{...n,taskHint:"sentence-similarity",...t==="feature-extraction"&&{forceTask:"sentence-similarity"}});if(!(Array.isArray(i)&&i.every(a=>typeof a=="number")))throw new u("Expected number[]");return i}async function ot(e,n){const t=await o(e,{...n,taskHint:"summarization"});if(!(Array.isArray(t)&&t.every(r=>typeof(r==null?void 0:r.summary_text)=="string")))throw new u("Expected Array<{summary_text: string}>");return t==null?void 0:t[0]}async function ut(e,n){const t=await o(e,{...n,taskHint:"table-question-answering"});if(!(typeof(t==null?void 0:t.aggregator)=="string"&&typeof t.answer=="string"&&Array.isArray(t.cells)&&t.cells.every(r=>typeof r=="string")&&Array.isArray(t.coordinates)&&t.coordinates.every(r=>Array.isArray(r)&&r.every(a=>typeof a=="number"))))throw new u("Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}");return t}async function ct(e,n){var r;const t=(r=await o(e,{...n,taskHint:"text-classification"}))==null?void 0:r[0];if(!(Array.isArray(t)&&t.every(a=>typeof(a==null?void 0:a.label)=="string"&&typeof a.score=="number")))throw new u("Expected Array<{label: string, score: number}>");return t}function O(e){return Array.isArray(e)?e:[e]}async function ft(e,n){const t=O(await o(e,{...n,taskHint:"text-generation"}));if(!(Array.isArray(t)&&t.every(r=>typeof(r==null?void 0:r.generated_text)=="string")))throw new u("Expected Array<{generated_text: string}>");return t==null?void 0:t[0]}async function*lt(e,n){yield*k(e,{...n,taskHint:"text-generation"})}async function yt(e,n){const t=O(await o(e,{...n,taskHint:"token-classification"}));if(!(Array.isArray(t)&&t.every(r=>typeof r.end=="number"&&typeof r.entity_group=="string"&&typeof r.score=="number"&&typeof r.start=="number"&&typeof r.word=="string")))throw new u("Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>");return t}async function dt(e,n){const t=await o(e,{...n,taskHint:"translation"});if(!(Array.isArray(t)&&t.every(r=>typeof(r==null?void 0:r.translation_text)=="string")))throw new u("Expected type Array<{translation_text: string}>");return(t==null?void 0:t.length)===1?t==null?void 0:t[0]:t}async function mt(e,n){const t=O(await o(e,{...n,taskHint:"zero-shot-classification"}));if(!(Array.isArray(t)&&t.every(r=>Array.isArray(r.labels)&&r.labels.every(a=>typeof a=="string")&&Array.isArray(r.scores)&&r.scores.every(a=>typeof a=="number")&&typeof r.sequence=="string")))throw new u("Expected Array<{labels: string[], scores: number[], sequence: string}>");return t}async function pt(e,n){const t=await o(e,{...n,taskHint:"text-generation",chatCompletion:!0});if(!(typeof t=="object"&&Array.isArray(t==null?void 0:t.choices)&&typeof(t==null?void 0:t.created)=="number"&&typeof(t==null?void 0:t.id)=="string"&&typeof(t==null?void 0:t.model)=="string"&&typeof(t==null?void 0:t.system_fingerprint)=="string"&&typeof(t==null?void 0:t.usage)=="object"))throw new u("Expected ChatCompletionOutput");return t}async function*wt(e,n){yield*k(e,{...n,taskHint:"text-generation",chatCompletion:!0})}async function gt(e,n){var a;const t={...e,inputs:{question:e.inputs.question,image:v(new Uint8Array(e.inputs.image instanceof ArrayBuffer?e.inputs.image:await e.inputs.image.arrayBuffer()))}},i=(a=O(await o(t,{...n,taskHint:"document-question-answering"})))==null?void 0:a[0];if(!(typeof(i==null?void 0:i.answer)=="string"&&(typeof i.end=="number"||typeof i.end>"u")&&(typeof i.score=="number"||typeof i.score>"u")&&(typeof i.start=="number"||typeof i.start>"u")))throw new u("Expected Array<{answer: string, end?: number, score?: number, start?: number}>");return i}async function bt(e,n){var a;const t={...e,inputs:{question:e.inputs.question,image:v(new Uint8Array(e.inputs.image instanceof ArrayBuffer?e.inputs.image:await e.inputs.image.arrayBuffer()))}},i=(a=await o(t,{...n,taskHint:"visual-question-answering"}))==null?void 0:a[0];if(!(typeof(i==null?void 0:i.answer)=="string"&&typeof i.score=="number"))throw new u("Expected Array<{answer: string, score: number}>");return i}async function ht(e,n){const t=await o(e,{...n,taskHint:"tabular-regression"});if(!(Array.isArray(t)&&t.every(r=>typeof r=="number")))throw new u("Expected number[]");return t}async function At(e,n){const t=await o(e,{...n,taskHint:"tabular-classification"});if(!(Array.isArray(t)&&t.every(r=>typeof r=="number")))throw new u("Expected number[]");return t}var kt=class{constructor(e="",n={}){_(this,"accessToken");_(this,"defaultOptions");this.accessToken=e,this.defaultOptions=n;for(const[t,i]of Object.entries(x))Object.defineProperty(this,t,{enumerable:!1,value:(r,a)=>i({...r,accessToken:e},{...n,...a})})}endpoint(e){return new vt(e,this.accessToken,this.defaultOptions)}},vt=class{constructor(e,n="",t={}){for(const[i,r]of Object.entries(x))Object.defineProperty(this,i,{enumerable:!1,value:(a,s)=>r({...a,accessToken:n,endpointUrl:e},{...t,...s})})}};const Ot=new kt("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");console.log("hey");chrome.runtime.onMessage.addListener((e,n,t)=>{async function i(){var a,s;let r="";for await(const c of Ot.chatCompletionStream({model:"meta-llama/Meta-Llama-3-8B-Instruct",messages:[{role:"user",content:e.message+" (explain in not more than 2 sentences)"}],max_tokens:500}))r+=((s=(a=c.choices[0])==null?void 0:a.delta)==null?void 0:s.content)||"";t(r)}return i(),!0});
